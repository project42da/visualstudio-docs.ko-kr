---
title: "디버깅 기본 사항: 레지스터 창 | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "FSharp"
  - "VB"
  - "CSharp"
  - "C++"
  - "JScript"
  - "VB"
  - "CSharp"
  - "C++"
helpviewer_keywords: 
  - "레지스터 창, 레지스터 창 정보"
  - "디버깅[Visual Studio], 레지스터 창"
ms.assetid: ab354047-053e-4f94-8ac1-26e761442b6f
caps.latest.revision: 22
caps.handback.revision: 22
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
---
# 디버깅 기본 사항: 레지스터 창
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

**레지스터** 창은 **옵션** 대화 상자의 **디버깅** 노드에서 주소 수준 디버깅을 활성화한 경우에만 사용할 수 있습니다.  
  
 레지스터는 프로세서\(CPU\) 내의 특정 위치로, 여기에는 프로세서에서 현재 사용 중인 작은 데이터가 저장됩니다.  소스 코드를 컴파일하거나 해석하면 데이터가 메모리에서 레지스터로 이동하고, 필요할 때 다시 레지스터에서 메모리로 이동하는 명령이 생성됩니다.  레지스터의 데이터에 액세스하는 것이 메모리의 데이터에 액세스하는 것보다 훨씬 빠릅니다. 그러므로 프로세서가 레지스터를 반복하여 로드하고 언로드하도록 하는 코드에 비해 프로세서에서 데이터를 레지스터에 보관하여 반복해서 데이터에 액세스하도록 하는 코드의 실행 속도가 훨씬 빠릅니다.  컴파일러가 쉽게 데이터를 레지스터에 보관하고 다른 최적화를 수행하도록 하려면 전역 변수의 사용을 피하고 가능한 한 지역 변수를 사용하는 것이 좋습니다.  이러한 방식으로 작성된 코드는 참조 집약성이 좋습니다.  C\/C\+\+와 같은 일부 언어에서 프로그래머는 언제나 변수를 레지스터에 보관하라고 컴파일러에 알리는 레지스터 변수를 선언할 수 있습니다.  자세한 내용은 [register Keyword](http://msdn.microsoft.com/ko-kr/5b66905a-2f7f-4918-bb55-5e66d4bc50f9)를 참조하십시오.  
  
 레지스터는 일반 용도와 특수 용도의 두 가지 유형으로 나눌 수 있습니다.  일반 용도의 레지스터는 두 숫자를 더하거나 배열 요소를 참조하는 등의 일반 작업을 위해 데이터를 보관합니다.  특수 용도의 레지스터는 특수한 목적과 전문적인 의미를 가집니다.  한 가지 좋은 예로 프로세서에서 프로그램의 호출 스택을 추적하는 데 사용하는 스택 포인터 레지스터를 들 수 있습니다.  일반적으로 프로그래머는 스택 포인터를 직접 조작하지 않습니다.  그러나 스택 포인터가 없으면 함수 호출이 끝났을 때 프로세서가 반환 위치를 알 수 없기 때문에 프로그램이 제대로 작동하려면 반드시 스택 포인터가 필요합니다.  
  
 대부분의 일반 용도 레지스터에는 단일 데이터 요소만 저장됩니다.  단일 데이터 요소에는 단일 정수, 부동 소수점 숫자, 배열 요소 등이 있습니다.  더 새로워진 몇몇 프로세서에는 작은 데이터 배열을 보관할 수 있는 벡터 레지스터라는 큰 레지스터가 있습니다.  벡터 레지스터에는 많은 양의 데이터가 보관되기 때문에 배열과 관련된 작업을 매우 빠르게 수행할 수 있습니다.  벡터 레지스터는 처음에는 비싼 고성능 슈퍼 컴퓨터에 사용되었으나 지금은 그래픽 작업이 많은 분야의 마이크로프로세서에 사용할 수 있게 되었습니다.  
  
 보통, 프로세서에는 각각 부동 소수점 연산과 정수 연산용으로 최적화되는 두 세트의 일반 용도 레지스터가 있으며,  이들을 부동 소수점 레지스터와 정수 레지스터라고 합니다.  
  
 관리 코드는 런타임에 마이크로프로세서의 실제 레지스터에 액세스하는 네이티브 코드로 컴파일됩니다.  공용 언어 런타임이나 네이티브 코드에 대한 이 실제 레지스터는 **레지스터** 창에 표시됩니다.  그러나 스크립트와 SQL은 레지스터 개념을 지원하지 않는 언어이므로 스크립트나 SQL 응용 프로그램에 대한 레지스터 정보는 **레지스터** 창에 표시되지 않습니다.  
  
 **레지스터** 창을 표시하는 데 대한 자세한 내용은 [레지스터 창 사용](../debugger/how-to-use-the-registers-window.md)을 참조하십시오.  
  
 **레지스터** 창에는 다음 예제와 같은 항목이 표시됩니다.  
  
```  
EAX = 003110D8  
```  
  
 \= 부호 왼쪽의 기호는 레지스터 이름\(이 경우 EAX\)입니다.  \= 부호 오른쪽의 숫자는 레지스터의 내용을 나타냅니다.  
  
 **레지스터** 창을 사용하면 단순히 레지스터의 내용을 보는 것 이상을 수행할 수 있습니다.  네이티브 코드의 중단 모드에 있으면 레지스터의 내용을 클릭하여 값을 편집할 수 있습니다.  이것은 임의로 수행하는 작업이 아닙니다.  편집하는 레지스터와 그 안에 들어 있는 데이터에 대해 모르면 부주의한 편집으로 인해 프로그램이 손상되거나 기타 원치 않는 결과가 발생할 수 있습니다.  그러나 여기서는 범위를 벗어나는 내용이므로 다양한 Intel 및 Intel 호환 프로세서의 레지스터 세트에 대해서는 설명하지 않습니다.  
  
## 레지스터 그룹  
 **레지스터** 창에서는 레지스터를 그룹으로 구성하여 간단하게 표시합니다.  **레지스터** 창을 마우스 오른쪽 단추로 클릭하면 그룹 목록이 들어 있는 바로 가기 메뉴가 나타나며, 이 메뉴는 필요에 따라 표시하거나 숨길 수 있습니다.  
  
## 참고 항목  
 [방법: 레지스터 창 사용](../debugger/how-to-use-the-registers-window.md)   
 [디버거 기본 사항](../debugger/debugger-basics.md)